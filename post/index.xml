<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on xietie blog</title>
    <link>https://xiet16.github.io/post/</link>
    <description>Recent content in Posts on xietie blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 21 Mar 2021 08:00:18 +0800</lastBuildDate><atom:link href="https://xiet16.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Data_Struct_SelectionSort</title>
      <link>https://xiet16.github.io/post/data_struct_selectionsort/</link>
      <pubDate>Sun, 21 Mar 2021 08:00:18 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_selectionsort/</guid>
      <description>择排序法： 每一次循环，都能取出一个最大值或者最小值 最后一个值不需要，不需要对比 假设有这个的一个数组 6,2,8,7,1,0,5 第一次循环：6 和 其他值比较， 取出最大值 8，剩下的 2,6,7,1,0,5（注意6的位置） 第二次循环：2和 其他值比较，取出最大值 7，剩下的 2,6,1,0,5 以此类推 所以循环次数是(n-1)*n 字符串比较： 可能是地址比较，不是字符串比较，go 的版本优化 “a”&amp;gt;“b” 每个字母分别比较： strings.Compare(&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;) </description>
    </item>
    
    <item>
      <title>Data_Struct_Link</title>
      <link>https://xiet16.github.io/post/data_struct_link/</link>
      <pubDate>Sun, 21 Mar 2021 01:16:40 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_link/</guid>
      <description>链表 地址不连续 删除插入O(1) 查找修改O(n) 顺序表： 查找修改 O(1) 内存连续 删除、插入O(n) 计算机理论上不存在大片连续的内存 为什么使用链表： 方便内存扩展，以及使用计算机内存碎片 节点的定义：数据+指向下一个数据的指针 type Node struct { data interface{} pNext *Node //存储下一个节点的地址 } 假设有一组数据： a d f h e 栈的特点：先进后出 实现: 头部插入，头部取出 type Node struct { data interface{} pNext *Node //存储下一个节点的地址 } 第一步：压入a 第二步：压入d, 这时数据的内存大致可以理解 d a 第三步：压入f, 这时数据的内存大致可以理解 f d a 同理：最后是 e h f d a 取得时候 从e 往下去 队列的特点 ： 先进先出 实现：尾部插入，头部取出，也可以反着来 type LinkQueue struct { front *Node //头部节点 rear *Node //尾部节点 } 第一步：压入a ， front , rear 都指向a 第二步：压入d, 这时数据的内存大致可以理解 d a , front 指向a, rear 都指向d 第三步：压入f, 这时数据的内存大致可以理解 f d a, front 指向a, rear 都指向f 同理：最后是 e h f d a, front 指向a, rear 都指向e 取的时候，操作front, 操作上的区别，队列是两个node, 主要它用来记录首尾的节点 </description>
    </item>
    
    <item>
      <title>Data_Struct_Queue</title>
      <link>https://xiet16.github.io/post/data_struct_queue/</link>
      <pubDate>Sat, 20 Mar 2021 22:25:58 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_queue/</guid>
      <description>队列: 特点： 先进先出 广度遍历 顺序队列的取出可能会很耗内存资源，因为每次都要往前移动 环形队列最多存储size-1个数据，空一格空格表示数据已满 假设 a b c d e f h k 假设用队列递归： 第一步：压入a, 取出a 第二步：压入bc,取出bc 第三步：压入def, 取出def 第四步：压入hk, 取出hk 假设用栈： 第一步：压入a, 取出a 第二步：压入bc,取出c 第三步：压入def,取出f 第四步：压入hk,取出k 第五步：取出hedb 所以栈是深度遍历 </description>
    </item>
    
    <item>
      <title>Aliyun_minikube_install</title>
      <link>https://xiet16.github.io/post/aliyun_minikube_install/</link>
      <pubDate>Fri, 19 Mar 2021 12:17:07 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/aliyun_minikube_install/</guid>
      <description>1、安装docker 2、安装minikube 下载minikube curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-1.9.2-0.x86_64.rpm sudo rpm -ivh minikube-1.9.2-0.x86_64.rpm 添加k8s 用户 sudo useradd k8s sudo passwd k8s sudo usermod -aG docker k8s chmod u+w /etc/sudoers vim /etc/sudoers chmod u-w /etc/sudoers 切换用户 su k8s 环境还是上一个用户的 su - k8s 3、执行minikube start minikube start \ --image-mirror-country=cn \ --registry-mirror=https://xxx.mirror.aliyuncs.com \ --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers \ --iso-url=https://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/iso/minikube-v1.9.0.iso 3、启动 minikube dashboard minikube dashboard 访问minikube dashboard http://47.104.237.197:33567/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/#/node?namespace=default 相关url: https://blog.csdn.net/qq_25951401/article/details/105961820 http://www.bubuko.com/infodetail-3673213.html curl -Lo minikube https://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v1.13.0/minikube-linux-amd64 &amp;amp;&amp;amp; chmod +x minikube &amp;amp;&amp;amp; sudo mv minikube /usr/local/bin/ </description>
    </item>
    
    <item>
      <title>SequenceList_Array</title>
      <link>https://xiet16.github.io/post/sequencelist_array/</link>
      <pubDate>Thu, 18 Mar 2021 20:52:13 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/sequencelist_array/</guid>
      <description>顺序表和数组
1、数组的特点：
(1)长度固定
(2)内存连续
(3)是值类型
2、假设有两组数组
d n f l o e
c b d n q i
顺序表的插入：
开辟一块空间，然后数据往后添加
顺序表的删除：（假设要删除数组1中的f）
找到f 后的数据，往前挪，然后删除e 对应的空间块，压缩内存
顺序表的合并：
开辟一块新的内存，一个个数据往后添加
顺序表效率：
查找：1次
删除：最坏n次
插入：最坏n次</description>
    </item>
    
    <item>
      <title>Go_tag</title>
      <link>https://xiet16.github.io/post/go_tag/</link>
      <pubDate>Thu, 18 Mar 2021 17:48:27 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/go_tag/</guid>
      <description>Tag: 结构体字段声明后面跟着一个可选字符串
使用场景:
结合中间件做数据校验</description>
    </item>
    
    <item>
      <title>Go_env_init</title>
      <link>https://xiet16.github.io/post/go_env_init/</link>
      <pubDate>Thu, 18 Mar 2021 15:33:27 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/go_env_init/</guid>
      <description>1、登陆https://studygolang.com/dl下载安装包(这里忽略安装过程)
2、环境配置(开启Module和代理，不然可能更新不下来依赖包)
go env -w GO111MODULE=on
go env -w GOPROXY=https://goproxy.io,direct
3、新建项目
(1)首先用vscode 打开一个空文件夹,添加main.go 文件 并编辑好代码
(2)在终端中执行以下命令
go mod init &amp;ldquo;your_project_name&amp;rdquo;
go mod tidy
go mod vendor
go modules 我的理解是go 项目依赖包管理。执行 go mod init &amp;ldquo;xxx&amp;rdquo; 以后 会生成一个go.mod的文件，这个文件展示的是项目所依赖的依赖包以及版本信息 所以如果要改某个包的版本，可以手动改，然后执行go mod tidy. go mod tidy 是更新依赖包命令，这里包含删除、新增、修改依赖包。go mod vendor 是讲依 赖包下载到vendor 文件夹。顺便提一下，go modules 是1.11后新加的特性之前 是GOPATH的方式</description>
    </item>
    
    <item>
      <title>ElasticSearch</title>
      <link>https://xiet16.github.io/post/elasticsearch/</link>
      <pubDate>Thu, 18 Mar 2021 09:29:52 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/elasticsearch/</guid>
      <description>1、ElasticSearch 规范:
2、ElasticSearch 踩过的坑:
(1)es中展示的是北京时间,存的时间是utc时间
&amp;ldquo;script&amp;rdquo;: { &amp;ldquo;source&amp;rdquo;: &amp;quot; return (new Date().getTime() - doc[&amp;lsquo;ArrivalDate&amp;rsquo;].value.toInstant().toEpochMilli() + 28800000) &amp;quot; }
(2)es中distinc 是不准的
&amp;ldquo;cardinality&amp;rdquo;: {&amp;ldquo;precision_threshold&amp;rdquo;: 100000,&amp;ldquo;field&amp;rdquo;: &amp;ldquo;Single_NO&amp;rdquo;}</description>
    </item>
    
    <item>
      <title>Design_Patterns</title>
      <link>https://xiet16.github.io/post/design_patterns/</link>
      <pubDate>Thu, 18 Mar 2021 08:51:04 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/design_patterns/</guid>
      <description>设计模式七大原则
代码网址:
https://github.com/xiet16/go_design_patterns
开闭原则: 对扩展开放，对修改关闭
理解: 当新增某一功能时，应该与原有的代码逻辑没有关系，也就是不需要修改原有的代码
里式替换原则:父类出现的任何地方，都可以用子类替换
理解:面向对象继承的体现，子类继承父类，子类就拥有父类的一切行为和属性
单一职责原则:一个类有且仅有一个引起它变化的原因，否则这个类就需要拆分
依赖倒置原则:抽象不依赖于具象，具象依赖抽象
理解:抽象类或者父类不关心继承类的实现，但是继承类要实现抽象类的约定
接口隔离原则:客户端不应该去依赖一个它不使用的接口(一个类对另一个类的依赖，应该在最小的接口上)
理解:某一功能接口的定义或者暴露，应该是尽可能少和紧密相关的
(迪米特原则)最少知道原则:高内聚
理解:后面这两个原则，暂时不做解释，虽有点的理解
合成复用原则:
理解:这个原则是说用组合的方式而不是继承的方式复用，但是我觉得要是具体场景，原则性不是很强</description>
    </item>
    
    <item>
      <title>Hugo_Web_Create</title>
      <link>https://xiet16.github.io/post/hugocreate/</link>
      <pubDate>Wed, 17 Mar 2021 19:29:21 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/hugocreate/</guid>
      <description>1、装好git 和hugo
2、新建博客站点
hugo new site myblog
3、进入myblog/themes 文件夹，下载主题并命名文件夹
git clone https://github.com/vaga/hugo-theme-m10c.git m10c
4、在myblog 文件夹下执行
hugo server -t m10c &amp;ndash;buildDrafts
5、在myblog 文件夹下创建md 文件
hugo new post/hugocreate.md
6、生成静态网页(https://github_name.github.io)要用自己名字，不然访问不了
hugo &amp;ndash;theme=m10c &amp;ndash;baseUrl=&amp;ldquo;https://xiet16.github.io&amp;rdquo; &amp;ndash;buildDrafts
7、编译好的网页放在./public 目录下面，所有要把public文件的内容传到https://github_name.github.io.git仓库上
8、再建一个仓库存myblog 项目就好了
9、上传可以建一个shell脚本
10、git 保存密码命令
git config &amp;ndash;global credential.helper store</description>
    </item>
    
  </channel>
</rss>
