<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>xietie blog</title>
    <link>https://xiet16.github.io/</link>
    <description>Recent content on xietie blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 07 Apr 2021 12:55:42 +0800</lastBuildDate><atom:link href="https://xiet16.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go_context</title>
      <link>https://xiet16.github.io/post/go_context/</link>
      <pubDate>Wed, 07 Apr 2021 12:55:42 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/go_context/</guid>
      <description>* 理解：context 可以理解主要为了处理多个goroutine间保存、读取、中断、取消等操作。 规则： 主要方法： 1 WithValue : 保存信息 2 WithTimeout 3 WithCancel 4 WithDeadline 问题： 它是如何传递到context 中的，它的修改有没有可能产生冲突 */ func ContextWithValueTest() { ctx := context.WithValue(context.Background(), &amp;quot;trace_id&amp;quot;, &amp;quot;11112233&amp;quot;) ctx = context.WithValue(ctx, &amp;quot;cookie&amp;quot;, &amp;quot;aasddget&amp;quot;) GetContextValue(ctx) defer ctx.Done() } /* func (c *cancelCtx) Value(key interface{}) interface{} { if key == &amp;amp;cancelCtxKey { return c } return c.Context.Value(key) } */ //递归式取值 func GetContextValue(ctx context.Context) { v1 := ctx.Value(&amp;quot;trace_id&amp;quot;) v1 = 334355 //这样改变不了它的值 v2 := ctx.</description>
    </item>
    
    <item>
      <title>Go_sync_map</title>
      <link>https://xiet16.github.io/post/go_sync_map/</link>
      <pubDate>Wed, 07 Apr 2021 12:48:29 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/go_sync_map/</guid>
      <description>sync 包的map: sync 包中的map 是一个结构体，实现了读写分离 （1）read 实际上是一个readOnly 结构体，readOnly 的m 实际上是一个entry 的键值对集合 // readOnly is an immutable struct stored atomically in the Map.read field. type readOnly struct { m map[interface{}]*entry amended bool // true if the dirty map contains some key not in m. } type entry struct {	p unsafe.Pointer // *interface{} } type Map struct { mu Mutex //优先从read 读取数据，因为它是只读的，所以它是线程安全的 read atomic.Value // readOnly dirty map[interface{}]*entry misses int } atomic 包： type Value struct { v interface{} } // ifaceWords is interface{} internal representation.</description>
    </item>
    
    <item>
      <title>Go_tools</title>
      <link>https://xiet16.github.io/post/go_tools/</link>
      <pubDate>Wed, 07 Apr 2021 12:45:12 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/go_tools/</guid>
      <description> (1)编译过程 go tool compile -N -l -S main.go (2) 查看内存逃逸 go build -gcflags=-m (3) 查看CPU 和 内存 go tool pprof mem.prof pprof 工具 runtime/pprof 和 net/http/pprof go run main.go -cpuprofile cpu.prof -memprofile mem.prof 查看.prof 文件 go tool pprof mem.prof http://127.0.0.1:8880/debug/pprof go tool pprof http://*:*/debug/pprof/profile 如果你的go程序不是web服务器，而是一个服务进程，那么你也可以选择使用net/http/pprof包，同样引入包net/http/pprof，然后在开启另外一个goroutine来开启端口监听。 比如： go func() { log.Println(http.ListenAndServe(&amp;quot;localhost:6060&amp;quot;, nil)) }() </description>
    </item>
    
    <item>
      <title>Go_init</title>
      <link>https://xiet16.github.io/post/go_init/</link>
      <pubDate>Wed, 07 Apr 2021 07:35:51 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/go_init/</guid>
      <description> init 函数用于包的初始化 特点： 在main 函数之前执行 每个包可以有多个init 函数，但是同一个的init 函数执行顺序是不确定的，根据包的依赖关系决定 每个源文件也可以有多个init 函数 init 函数不能被其他函数调用 即使包被导入多次，初始化只需要一次 </description>
    </item>
    
    <item>
      <title>Go_iota</title>
      <link>https://xiet16.github.io/post/go_iota/</link>
      <pubDate>Tue, 06 Apr 2021 18:48:06 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/go_iota/</guid>
      <description>iota 是go语言常量计数器，只能在常量表达式中使用 每出现一次const , iota 就会被重置为0， const 中每新增一行，iota 就计数一次，相当于const 的行索引 func IotaTest() { fmt.Println(Bt,&amp;quot;--&amp;gt;&amp;quot;,Kb,&amp;quot;--&amp;gt;&amp;quot;,Mb,&amp;quot;--&amp;gt;&amp;quot;,Km,&amp;quot;--&amp;gt;&amp;quot;,Zm,&amp;quot;--&amp;gt;&amp;quot;,a) } func IotaTest() { fmt.Println(Bt,&amp;quot;--&amp;gt;&amp;quot;,Kb,&amp;quot;--&amp;gt;&amp;quot;,Mb,&amp;quot;--&amp;gt;&amp;quot;,Km,&amp;quot;--&amp;gt;&amp;quot;,Zm,&amp;quot;--&amp;gt;&amp;quot;,a,&amp;quot;--&amp;gt;&amp;quot;,Em,&amp;quot;--&amp;gt;&amp;quot;,Hm) } const a = iota const ( Bt = 8 Kb = 8&amp;lt;&amp;lt;iota Mb Km =iota Zm = 100 Em Hm ) 8 --&amp;gt; 16 --&amp;gt; 32 --&amp;gt; 3 --&amp;gt; 4 --&amp;gt; 0 --&amp;gt; 100 --&amp;gt; 100 Em和Hm 为什么是100 ，就和Mb 为什么是 8&amp;lt;&amp;lt;iota 一样，const 在编译 是，取的是上一个表达式来解析 const ( _ = iota //0 KB = 1&amp;lt;&amp;lt;(10*iota) //1&amp;lt;&amp;lt;10*1 MB //1&amp;lt;&amp;lt;10*2 GB ) 常量的值必须在编译期间确定。因此不能将函数的返回值赋给常量，因为函数调用发生在运行期 </description>
    </item>
    
    <item>
      <title>Go_gin_router</title>
      <link>https://xiet16.github.io/post/go_gin_router/</link>
      <pubDate>Mon, 05 Apr 2021 10:39:49 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/go_gin_router/</guid>
      <description>1 设置环境(debug release) 2 初始化内核gin.Engine， 3 注册路由 gin.Engine 是一个结构体，结构体中包含RouterGroup，RouterGroup 也是一个结构体，定义如下 type RouterGroup struct { Handlers HandlersChain basePath string engine *Engine root bool } gin.Engine.Use() 方法: 主要是拼接中间件,rebuild404Handlers 和rebuild405Handlers调用的居然是同一个方法，为什么 func (engine *Engine) Use(middleware ...HandlerFunc) IRoutes { engine.RouterGroup.Use(middleware...) engine.rebuild404Handlers() engine.rebuild405Handlers() return engine } gin.Engine.RouterGroup.Use() 方法 func (group *RouterGroup) Use(middleware ...HandlerFunc) IRoutes { group.Handlers = append(group.Handlers, middleware...) return group.returnObj() } gin.Engine 注入action 实际上还是注入RouterGroup func (group *RouterGroup) GET(relativePath string, handlers ...HandlerFunc) IRoutes { return group.</description>
    </item>
    
    <item>
      <title>Mysql_Optimistic_Pessimistic</title>
      <link>https://xiet16.github.io/post/mysql_optimistic_pessimistic/</link>
      <pubDate>Sat, 03 Apr 2021 12:21:09 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/mysql_optimistic_pessimistic/</guid>
      <description> 乐观锁： 通过版本实现 悲观锁： 通过数据库机制实现 mysql inodb for update 使用规则： 要在事务里面使用，才能锁住所查询的资源，可以是多行 锁住的是行数据，不只是某个字段，所以如果另一个事务去修改其他字段，也是不行的 锁的是锁机制，就是说不允许再加锁，并没有锁住查询（正常的查询还是可以查到数据的） </description>
    </item>
    
    <item>
      <title>Nosql_PanicBuy_Solution</title>
      <link>https://xiet16.github.io/post/nosql_panicbuy_solution/</link>
      <pubDate>Tue, 30 Mar 2021 08:58:48 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/nosql_panicbuy_solution/</guid>
      <description>秒杀系统分析 限流： 消峰：由于有瞬间有大量用户涌入 异步处理： 内存缓存：数据库读写有瓶颈，因为它的读写是基于磁盘IO 单机版的redis qps 大概在8w 左右 集群版访问原理：假设有三个Node1、Node2、Node3 ， 第一次访问A商品数据时，通过hash ，找到A商品所在的Node ,然后返回 所以，集群只是分担了总的Qps , 而不是提高了Qps,单个商品的Qps 并没有提升 在12核cup 的条件下，单个接口能承受20-30w 通过go 的并发机制+redis 可以实现商品高并发下的秒杀。但是无法解决数据库订单量的生成以及商品数的修改。这个时候就要用到消息队里 流量控制： 消息队列：避免瞬间的流量给数据库带来巨大的压力， 使用模式autoack :true +qos 手动应答的方式,每次只消费一个订单 Qos{ prefetchcount :1, 每次只消费一个 prefetchSize :0 , 服务器传递的最大容量，8个字节 global :false, //只对当前消费队列 ，如果true 对所有channel 可用 } redis 分布式锁：setnx + 续命锁（redisson 用的是hset +续命锁） redis 主从锁失效问题：只有半数以上的锁加成功以后，才返回加锁成功 如何提高分布式锁性能：分段锁 缓存数据库双写不一致：缓存双删（问题没法解决）、分布式锁 </description>
    </item>
    
    <item>
      <title>Nosql_Redis</title>
      <link>https://xiet16.github.io/post/nosql_redis/</link>
      <pubDate>Mon, 29 Mar 2021 16:09:32 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/nosql_redis/</guid>
      <description>1、redis 常用数据类型 string list hash set zset 2、redis 有效期 (1)redis 有效期的处理实际是对键的处理，Expires 保存了所有键的过期时间 (2)以下是四种过期策略（无过期值为-1） EXPIRE 将key 的生存时间为ttl 秒 PEXPIRE 将key 的生存时间设为ttl 毫秒 EXPIREAT 以时间戳的方式设置生存时间为timestamp秒 PEXPIREAT 毫秒的时间搓 (3)例子 set key1 &#39;value1&#39; exipre key1 20 expireat key1 1545470885 persist key1 //取消有效期，也就是设置其有效期为-1 (4) 清除失效数据机制 定时删除：在设置键的过期时间的时候创建一个定时器，当过期时间到的时候立马执行删除操作。不过这种处理方式是即时的，不管这个时间内有多少过期键，不管服务器现在的运行状况，都会立马执行 惰性删除：惰性删除策略不会在键过期的时候立马删除，而是当外部指令获取这个键的时候才会主动删除。处理过程为：接收get执行、判断是否过期（这里按过期判断）、执行删除操作、返回nil（空） 定期删除：定期删除是设置一个时间间隔，每个时间段都会检测是否有过期键，如果有执行删除操作 (5) redis 内存满了 设置内存大小 config set maxmemory 100MB /config get maxmemery 内存淘汰机制： noeviction(默认)：不再提供写请求，返回错误 allkeys-lru : 在所有的key 中使用lru 算法对数据进行淘汰 volatile-lru: 在设置了&amp;quot;过期时间&amp;quot;的key 中使用lru 算法进行淘汰 allkeys-random : 在所有key 中随机淘汰 volatitle-random: 在设置了“过期时间”的key中设置了淘汰 volatitle-ttl: 看着就知道了，最早过期的最新淘汰 3、redis 持久化 &amp;lt;https://baijiahao.</description>
    </item>
    
    <item>
      <title>Data_Struct_Sort_GoroutineShellSort</title>
      <link>https://xiet16.github.io/post/data_struct_sort_goroutineshellsort/</link>
      <pubDate>Fri, 26 Mar 2021 14:24:02 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_sort_goroutineshellsort/</guid>
      <description>/* 希尔排序是插入排序的一种，是插入排序的优化 希尔排序时间复杂度是 O(n^(1.3-2))， 空间复杂度为常数阶 O(1)。 希尔排序没有时间复杂度为 O(n(logn)) 的快速排序算法快 ， 因此对中等大小规模表现良好， 但对规模非常大的数据排序不是最优选择，总之比一般 O(n^2 ) 复杂度的算法快得多。 这是插入排序: [6,2,8,7,1,0,5] 原数组 [6 2 8 7 1 0 5] 第一次循环从下标a1-&amp;gt;a0 (前面的数据是循环后的结果) [8 6 2 7 1 0 5] 第三次循环从下标a2-a0 [8 7 6 2 1 0 5] [8 7 6 2 1 0 5] [8 7 6 2 1 0 5] [8 7 6 5 2 1 0] 这是插入排序 [7 2 8 6 1 0 5] [7 2 8 6 1 0 5] 3 步长-&amp;gt;start: 0 插入排序后: [7 2 8 6 1 0 5] 备注: 前面两个是子插入过程，这一行是结果，实际排序 a[0],a[3],a[6] 3 个值，需要排2轮 [7 2 8 6 1 0 5] 3 步长-&amp;gt;start: 1 插入排序后: [7 2 8 6 1 0 5] 备注: 前面1行是子插入过程，这一行是结果，实际排序 a[1],a[4] [7 2 8 6 1 0 5] 3 步长-&amp;gt;start: 2 插入排序后: [7 2 8 6 1 0 5] 备注: 前面1行是子插入过程，这一行是结果，实际排序 a[2],a[5] [7 2 8 6 1 0 5] [8 7 2 6 1 0 5] [8 7 6 2 1 0 5] [8 7 6 2 1 0 5] [8 7 6 2 1 0 5] [8 7 6 5 2 1 0] 1 步长-&amp;gt;start: 0 插入排序后: [8 7 6 5 2 1 0] 备注: 因为此时补偿为1，所以这个是一轮全插入 同一步长，是可以异步的 */ func GoroutineShellSort(arr []int) []int{ length:=len(arr) if length &amp;lt;2 { return arr } wg:=sync.</description>
    </item>
    
    <item>
      <title>Data_Struct_Storage_HashTable</title>
      <link>https://xiet16.github.io/post/data_struct_storage_hashtable/</link>
      <pubDate>Fri, 26 Mar 2021 09:30:06 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_storage_hashtable/</guid>
      <description>/* 哈希函数 哈希的原理是:任何一个字符串都能转换为一个整形，同一字符串对应的哈希值一定相同，不同字符串对应的哈希值一定不同，同一哈希值对应的字符串不一定相同 哈希表: 不适合频繁插入删除 可以实现快速查找 */ const ( Deleted = iota //数据已经被删除 MintableSize =100 //哈希表大小 legimate =iota //已经存在的合法数据 Empty = iota //数据为空 ) //自定义哈希 func MySha(str interface{},tableSize int) int { var hashVal int= 0 var chars []byte if strings,ok:=str.(string);ok { chars = []byte(strings) } for _,v := range chars{ hashVal = (hashVal&amp;lt;&amp;lt;17|123&amp;amp;234)+int(v) } return hashVal%MintableSize } //sha256 func MySha256(str interface{},tableSize int) int { shaobj:=sha256.New() shaobj.Write([]byte(str.(string))) //哈希 mybytes :=shaobj.Sum(nil) var hashVal int= 0 for _,v := range mybytes{ hashVal = (hashVal&amp;lt;&amp;lt;17|123&amp;amp;234)+int(v) } return hashVal%MintableSize } //定义哈希函数指针 type HashFunc func(data interface{},tableSize int) int //函数指针 //哈希表--&amp;gt; 哈希结构体集合--&amp;gt;哈希结构体 type HashEntry struct { data interface{} //数据 kind int //类型 } type HashTable struct { tableSize int //哈希表大小 theCells [] *HashEntry //数组，每一个元素就是指针，指向哈希结构 hashFunc HashFunc //调用哈希函数 } type HashTableGo interface { Find(data interface{}) int Insert (data interface{}) Empty() GetValue(index int) } func NewHashTable(size int,hash HashFunc) (*HashTable,error) { if size &amp;lt;MintableSize { return nil,errors.</description>
    </item>
    
    <item>
      <title>Data_Struct_Storage_Heap</title>
      <link>https://xiet16.github.io/post/data_struct_storage_heap/</link>
      <pubDate>Fri, 26 Mar 2021 09:24:26 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_storage_heap/</guid>
      <description>/* 堆原理 */ //接口 type Item interface { Less(than Item) bool //比大小 } // 最小堆 最大堆 type Heap struct { lock *sync.Mutex //线程安全 data []Item //数组 min bool //最小堆还是最大堆 } //标准堆 func NewHeap()*Heap { return &amp;amp;Heap{new(sync.Mutex),make([]Item,0),true} } //最小dui func NewMin()*Heap { return &amp;amp;Heap{new(sync.Mutex),make([]Item,0),true} } //最大堆 func NewMax()*Heap { return &amp;amp;Heap{new(sync.Mutex),make([]Item,0),false} } //是否为空 func (h *Heap)IsEmpty() bool { return len(h.data)==0 } //获取长度 func (h *Heap)Len()int { return len(h.data) } //获取数据 func (h *Heap)Get(index int)Item { return h.</description>
    </item>
    
    <item>
      <title>Data_Struct_Storage_Stack</title>
      <link>https://xiet16.github.io/post/data_struct_storage_stack/</link>
      <pubDate>Fri, 26 Mar 2021 08:00:24 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_storage_stack/</guid>
      <description>/* 栈是一种数据结构,是只能在一端插入和删除数据的特殊线性表 先进后出 入栈和出栈都在栈顶进行 栈最主要的是保存了函数调用相关信息:其中最主要的是 1、函数的返回地址和参数 2、临时变量 */ type StackArray interface { Clear() //清空 Size() int //大小 Pop() interface{} //弹出 Push(data interface{}) //压入 IsFull()bool //是否满 IsEmpty()bool //是否为空 } type Stack struct { dataSource []interface{} capsize int //最大范围 currentsize int //当前大小 } func NewStack() *Stack { stack:= new(Stack) stack.dataSource =make([]interface{},0,10) stack.capsize =10 stack.currentsize =0 return stack } func (stack *Stack)Clear() { //go 自动回收内存 stack.dataSource =make([]interface{},0,10) stack.capsize =10 stack.currentsize =0 } func (stack *Stack)Size() int { return stack.</description>
    </item>
    
    <item>
      <title>Data_Struct_Storage_UnsafeQueue</title>
      <link>https://xiet16.github.io/post/data_struct_storage_unsafequeue/</link>
      <pubDate>Fri, 26 Mar 2021 07:58:13 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_storage_unsafequeue/</guid>
      <description>/* 非线程安全队列 */ type IQueue interface { Size() int //大小 Front() interface{} End() interface{} IsEmpty() bool EnQueue(data interface{}) //入队 DeQueue()interface{} Clear()//清空 } type Queue struct { dataStroe []interface{} // theSize int } func NewQueue()*Queue { queue :=new(Queue) queue.dataStroe =make([]interface{},0) queue.theSize=0 return queue } func (q *Queue)Size() int { return q.theSize } func (q *Queue)Front() interface{}{ if q.theSize ==0 { return nil } return q.dataStroe[0] } func (q *Queue)End() interface{}{ if q.</description>
    </item>
    
    <item>
      <title>Data_Struct_Storage_Compare</title>
      <link>https://xiet16.github.io/post/data_struct_storage_compare/</link>
      <pubDate>Fri, 26 Mar 2021 07:53:35 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_storage_compare/</guid>
      <description> 数据结构存储主要有 数组、链表 稍微上层的有： 队列(queue)、堆(heap)、栈(stack) 为什么这么说呢？ 因为这三个本质上就是对数组或者链表的封装，然后实现它们固有的特性 1、队列是先进先出， 2、栈是后进先出， 3、堆是一种二叉树，堆本身在压缩或者插入的时候实现了内部的自定义排序，从而实现了最小堆或者最大堆 这也许就是为什么函数的信息和形参放在栈中，而函数的调用放在堆中的原因，因为栈是非抢占式的，而堆可以设置优先级 所有的递归都可以用循环+栈， 或者循环+队列实现， 不同的是栈是广度遍历，队列是深度遍历 </description>
    </item>
    
    <item>
      <title>Data_Struct_SingleLink_BubbleSort</title>
      <link>https://xiet16.github.io/post/data_struct_singlelink_bubblesort/</link>
      <pubDate>Thu, 25 Mar 2021 19:33:38 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_singlelink_bubblesort/</guid>
      <description>/* 单链表冒泡排序: 冒泡排序这里就不说了，可以看数组篇的冒泡排序说明 单链表的冒泡和数组的冒泡不一样的地方是不能随意交换 单链表是单向的，所以要涉及4个节点: 当前节点, 当前节点的前一个节点，当前节点的下一个节点，以及结束节点， */ func LinkBubbleSort(list *SingleLinkList) { if list.head==nil || list.head.pNext==nil { return } phead := list.head cur := phead.pNext //当前循环节点,冒泡排序从第一个数开始，每次轮询都得出一个最值 end := &amp;amp;SingleLinkNode{} //已经排过序的 pre :=phead //前一个节点 for cur!=end{ for cur.pNext!=nil &amp;amp;&amp;amp; cur.pNext!=end { if cur.value.(int) &amp;gt; cur.pNext.value.(int) { //如果大于，指针往下移 pre =cur cur = cur.pNext }else { //交换值 back := cur.pNext cur.pNext=cur.pNext.pNext back.pNext=cur //赋值前一个节点 pre.pNext = back pre=back } } //重新初始化 end = cur //标记已排序过的节点 pre = phead cur=phead.</description>
    </item>
    
    <item>
      <title>Data_Struct_FabonacciSearch</title>
      <link>https://xiet16.github.io/post/data_struct_fabonaccisearch/</link>
      <pubDate>Thu, 25 Mar 2021 11:01:40 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_fabonaccisearch/</guid>
      <description> /* 斐波那契查找: 二分查找和中值查找的扩展，因为它的比例逐渐接近于黄金分割点，也叫黄金分割点查找 */ //构建斐波那契数组 func makeFabArray(arr []int) []int { length:=len(arr) max:= arr[length-1] fabArr:=make([]int,3,3) fabArr[0]=1 fabArr[1]=2 fabArr[2]=3 for i:=2;i &amp;lt;length-1 &amp;amp;&amp;amp; fabArr[i]&amp;lt; max;i++ { fabArr=append(fabArr,fabArr[i]+fabArr[i-1]) } return fabArr } func FabonacciSearch(arr []int,value int) int { length:=len(arr) //获取斐波那契数组 fabArr:=makeFabArray(arr) fmt.Println(fabArr) //创建填充的数组 fillArrLength:=fabArr[len(fabArr)-1] fillArr :=make([]int,fillArrLength) for i:=0;i&amp;lt;length;i++ { fillArr[i]=arr[i] } for i:=length;i&amp;lt;fillArrLength;i++ { fillArr[i]=arr[length-1] } fmt.Println(fillArr) left,mid,right:=0,0,length-1 index := len(fabArr)-1 for left&amp;lt;right { mid=left+fabArr[index-1]-1 //斐波那契切割 if value &amp;lt; fillArr[mid]{ right=mid-1 index-- }else if value&amp;gt;fillArr[mid] { left=mid+1 index -=2 //为什么减2，减1 肯定是不行，但为什么是2 }else { if mid&amp;gt;right { return right //越界 }else { return mid } } } return -1 } </description>
    </item>
    
    <item>
      <title>Data_Struct_MiddleLink</title>
      <link>https://xiet16.github.io/post/data_struct_middlelink/</link>
      <pubDate>Wed, 24 Mar 2021 22:47:25 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_middlelink/</guid>
      <description> /* 求中间值，或者说求n份之一值 */ func (list *SingleLinkList)GetMiddle() *SingleLinkNode { if list.head.pNext ==nil{ return nil }else { phead1:=list.head phead2:=list.head for phead2!=nil&amp;amp;&amp;amp;phead2.pNext!=nil { phead2 = phead2.pNext.pNext phead1 =phead1.pNext } return phead1 } } </description>
    </item>
    
    <item>
      <title>Data_Struct_ReverseLink</title>
      <link>https://xiet16.github.io/post/data_struct_reverselink/</link>
      <pubDate>Wed, 24 Mar 2021 22:32:22 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_reverselink/</guid>
      <description> package Link /* 链表反转 */ func (list *SingleLinkList)ReverseLink() { if list.head ==nil ||list.head.pNext ==nil { return } var pre *SingleLinkNode var cur *SingleLinkNode =list.head.pNext //这个循环的最主要目的是给当前节点赋值上一个节点，然后继续推进 for cur!=nil { curNext:= cur.pNext //1 备份当前节点 cur.pNext = pre //2 当前节点等于上一节点，注意，这个pre 是上一次循环赋值的，是上一循环的当前节点 pre =cur //3 给pre 赋值当前节点，供下一次循环使用，第一次进来pre 是nil ,最后一个值不进来所以需要在外面赋值 cur=curNext //4 持续推进 } list.head.pNext=pre //最后一个值 } </description>
    </item>
    
    <item>
      <title>Data_Struct_MiddleSearch</title>
      <link>https://xiet16.github.io/post/data_struct_middlesearch/</link>
      <pubDate>Wed, 24 Mar 2021 11:30:14 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_middlesearch/</guid>
      <description>中值查找: 二分查找的优化，本质是值比例查找 /* 中值搜索: 根据值比例求中值 1,2,3,4,5,6,7,8,9,10 共10位数，取 8 在哪个位置 left:0 right:9 data/就得出值 (arr[right]-arr[left])/(right-left) 没份的间隔是多少 求data 大概在第几份 (data-arr[left])*(right-left)/(arr[right]-arr[left]) = n 中间值下标就是 left+ n */ func MiddleSearch(arr []int,data int) []int { length:=len(arr) if length &amp;lt;1 { return nil } left:=0 right:=length-1 res:=[]int{} if left&amp;lt;right { //mid:=(right+left)/2 //优化欠 allv := float64(arr[right]-arr[left]) leftv := float64(data-arr[left]) diff := float64(right-left) mid:= int(float64(left)+ leftv/allv*diff) if mid&amp;lt;0 || mid &amp;gt;length { return nil } if arr[mid] &amp;gt;data { right =mid-1 }else if arr[mid]&amp;lt;data { left = mid+1 }else { res =append(res,mid) for i:=mid+1;i&amp;lt;=right;i++ { if arr[i]==data { res=append(res,i) }else { break } } for i:=mid-1;i&amp;gt;=left;i-- { if arr[i]==data { res=append(res,i) }else { break } } } } return res } </description>
    </item>
    
    <item>
      <title>Data_Struct_BinarySearch</title>
      <link>https://xiet16.github.io/post/data_struct_binarysearch/</link>
      <pubDate>Wed, 24 Mar 2021 11:23:01 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_binarysearch/</guid>
      <description>二分查找： 从中间查找，前提是排了序的数据 关键代码： func BinarySearch(arr[] int ,data int) int { left:=0 right:=len(arr)-1 for left &amp;lt;right{ mid := (left+right)/2 if arr[mid]&amp;gt;data { left =mid+1 }else if arr[mid]&amp;lt;data{ right=mid-1 }else { return mid } } return -1 } </description>
    </item>
    
    <item>
      <title>Data_Struct_QuickSortPlus</title>
      <link>https://xiet16.github.io/post/data_struct_quicksortplus/</link>
      <pubDate>Wed, 24 Mar 2021 10:16:01 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_quicksortplus/</guid>
      <description>快速排序升级算法： 前面的快速排序有个弊端，就是频繁的开辟数组，造成内存不断的飙升，而且数据超过2000w时，排序的时间大大增加 原理: 取基数，小于基数的往左边插入，大于基数的往右边插入，等于的记录等于的起始位置 所以会有几个下标，[0-lt] 是小于 基数的下标，[lt-i]是等于基数的下标，[i-gt]是移动下标，当i==gt 时，此时[gt-length]是大于基数的下标 /* 3,2,8,6,9 1,5 取基数，这里每次都取arr[0] 小于的从第0位开始交换 大于的从最后一位开始放尽管扔到一变就好了 3,2,8,6,9,1,5 第一次循环，vdata=arr[0]=3 ,不动 3,2,5,6,9,1,8 第二次循环 3&amp;lt;a[2]=8 gt-1 3,2,1,6,9,5,8 第三次循环 3&amp;lt;a[2]=5 gt -1 3,2,1,6,9,5,8 第四次循环 3&amp;gt;a[2]=1 这时候是不变的 3,2,1,9,6,5,8 第六次循环 3《a[3]=6 这时候是不变的 gt-1 3,2,1,9,6,5,8 第七次循环 3《a[3]=9 这时候是不变的 gt-1 ， 这个时候i==gt 1,2,3,9,6,5,8 第八次循环 */ 关键代码: func QuickInsertSort(arr []int,left int,right int) []int { //数组只剩3个时，用插入排序 if right-left &amp;lt;3 { InsertQuick(arr,left,right) }else { //随机找一个数字 Swap(arr,left,rand.Int()%(right-left+1)+left) vdata :=arr[left] //基数 lt :=left //arr[left+1,lt] &amp;lt;vdata gt:=right+1 //arr[gt.</description>
    </item>
    
    <item>
      <title>Data_Struct_CockSort</title>
      <link>https://xiet16.github.io/post/data_struct_cocksort/</link>
      <pubDate>Tue, 23 Mar 2021 07:14:40 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_cocksort/</guid>
      <description>鸡尾酒排序: 本质就是循环双边冒泡，每次冒泡都会有一个值沉底或值飘起 假设有一组数据: [350 180 166 100 97 87 35 32 16 15 6 5 4 4 3 2] 下边关键代码部分运行过程: 0 [4 6 32 5 166 4 350 180 3 2 87 15 97 35 16 100] 1 [6 32 5 166 4 350 180 100 4 3 2 87 15 97 35 16] 2 [32 6 166 5 350 180 100 97 4 4 3 2 87 15 35 16] 3 [32 166 6 350 180 100 97 87 5 4 4 3 2 35 15 16] 4 [166 32 350 180 100 97 87 35 6 5 4 4 3 2 16 15] 5 [166 350 180 100 97 87 35 32 16 6 5 4 4 3 2 15] 6 [350 180 166 100 97 87 35 32 16 15 6 5 4 4 3 2] 7 [350 180 166 100 97 87 35 32 16 15 6 5 4 4 3 2] 关键代码: for i:=0;i&amp;lt;length;i++ { left :=0; right :=length-1 for left&amp;lt;=right { if arr[left]&amp;lt;arr[left+1] { arr[left],arr[left+1]=arr[left+1],arr[left] } left++ if arr[right]&amp;gt;arr[right-1] { arr[right],arr[right-1]=arr[right-1],arr[right] } right-- } fmt.</description>
    </item>
    
    <item>
      <title>Go_channel</title>
      <link>https://xiet16.github.io/post/go_channel/</link>
      <pubDate>Mon, 22 Mar 2021 19:42:00 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/go_channel/</guid>
      <description>channel： 特点： 1、同一时间点，只能被一个协程访问,也就是说它是同步的 、线程安全的， 2、管道分为有缓冲和无缓冲 3、无缓冲情况下：在接收者准备好之前，发送者是阻塞的也就是说，首先得有接收者开始接收，才会开始发送 4、有缓冲情况下：在buf 满之后，直到有接收者接收，发送者才可以发送 type hchan struct { qcount uint // total data in the queue buf队列中的数据个数 dataqsiz uint // size of the circular queue buf 的长度 buf unsafe.Pointer // points to an array of dataqsiz elements 数据缓冲 elemsize uint16 // 每个元素的大小 closed uint32 // 1代表队列已经关闭 elemtype *_type // element type 元素的类型 sendx uint // send index 环形发送队列的下标 recvx uint // receive index 环形接收队列的下标 recvq waitq // list of recv waiters 在等待中的接收线程队列 sendq waitq // list of send waiters 在等待中的发送线程队列 // lock protects all fields in hchan, as well as several // fields in sudogs blocked on this channel.</description>
    </item>
    
    <item>
      <title>Data_Struct_CountSort</title>
      <link>https://xiet16.github.io/post/data_struct_countsort/</link>
      <pubDate>Mon, 22 Mar 2021 12:05:28 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_countsort/</guid>
      <description>统计计数算法： 不基于元素比较的排序算法 举个简单的例子讲吧： 假设有一组数据： 4，3，6, 9，7 ，8 (1)取其中最大值9，这里通过一轮比较就可以得出 (2)建一个长度为9+1=10的数组countarr，用数组的下标代表数据， 也就是arr[9] 中的[9]代表9 ,arr[9] 代表出现多少次 (3) 统计次数后的countarr: [0 0 0 1 1 0 1 1 1 1] (4) 其实这个时候已经排好序了，只要用下标和个数循环输出就行 (5) 有时候我们想知道，数组中的任意某个值是第几位，这时候进一步衍生下面的步骤 循环往后叠加，countarr[i]+=countarr[i-1],这里需要理解，比如[0 0 0 1 1 变为 [0 0 0 1 2 这里的1变为2，代表的是[4] 排在第二位，以此类推完整的是这样 [0 0 0 1 2 2 3 4 5 6] 最后一位6很容易看出来，一共有6个数据，下标[9] 在第六位 关键代码： maxValue := GetMaxValue(arr) countArr:=make([]int,maxValue+1) res:=make([]int,length) for i:=0;i&amp;lt;length;i++ { countArr[arr[i]]++ //统计次数 } fmt.Println(&amp;quot;统计次数:&amp;quot;,countArr) for i:=1;i&amp;lt;=maxValue;i++ { countArr[i]+=countArr[i-1] //叠加 } fmt.</description>
    </item>
    
    <item>
      <title>Data_Struct_RadixSort</title>
      <link>https://xiet16.github.io/post/data_struct_radixsort/</link>
      <pubDate>Mon, 22 Mar 2021 12:04:47 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_radixsort/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Data_Struct_ShellSort</title>
      <link>https://xiet16.github.io/post/data_struct_shellsort/</link>
      <pubDate>Mon, 22 Mar 2021 08:45:08 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_shellsort/</guid>
      <description> 希尔排序： 特点: 是一种步长收缩算法，一般初次增量为序列的一半 本质上是一种分组 时间复杂度为O(n3/2) 可以用多线程 关键点： 如何定义步长 关键代码 gap :=length/2 for gap&amp;gt;0 { for i:=0;i&amp;lt;gap;i++ { ShellStep(arr,i,gap) } gap/=2 } //间隔为步长的插入算法 length:=len(arr) for i:=start+gap;i&amp;lt;length;i+=gap { //间隔为gap 的插入排序 backup :=arr[i] j:=i-gap //数据循环往后移动 for j&amp;gt;=0 &amp;amp;&amp;amp; backup&amp;gt;arr[j]{ arr[j+gap] = arr[j] j-=gap } arr[j+gap]=backup //插入 fmt.Println(arr) } </description>
    </item>
    
    <item>
      <title>Data_Struct_MergeSort</title>
      <link>https://xiet16.github.io/post/data_struct_mergesort/</link>
      <pubDate>Sun, 21 Mar 2021 22:13:32 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_mergesort/</guid>
      <description>归并排序： 将数据切割成多段进行排序 然后再多段合并 好处: 内存不够时，可以节约内存 func MergeSort(arr []int) []int { length:=len(arr) if length&amp;lt;=1 { return arr } n:=length/2 frontArr :=MergeSort(arr[:n]) rearArr :=MergeSort(arr[n:]) return merge(frontArr,rearArr) } func merge(leftArr,rightArr []int)[]int { leftIndex:=0 rightIndex :=0 res:=[]int{} for leftIndex&amp;lt;len(leftArr)&amp;amp;&amp;amp;rightIndex&amp;lt;len(rightArr){ if leftArr[leftIndex] &amp;gt;rightArr[rightIndex] { res=append(res,leftArr[leftIndex]) leftIndex ++ }else if leftArr[leftIndex] &amp;lt; rightArr[rightIndex] { res = append(res,rightArr[rightIndex]) rightIndex++ }else { res =append(res,leftArr[leftIndex],rightArr[rightIndex]) leftIndex++ rightIndex++ } } for len(leftArr)&amp;gt;leftIndex { res =append(res,leftArr[leftIndex]) leftIndex++ } for len(rightArr)&amp;gt;rightIndex { res =append(res,rightArr[rightIndex]) rightIndex++ } return res } </description>
    </item>
    
    <item>
      <title>Data_Struct_OddEvenSort</title>
      <link>https://xiet16.github.io/post/data_struct_oddevensort/</link>
      <pubDate>Sun, 21 Mar 2021 19:09:35 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_oddevensort/</guid>
      <description>奇偶排序： 以奇数和偶数为基准，对整个数组进行排序，排序的元素只有两个元素（基数和右侧相邻元素） 如何证明奇偶排序的可行性？后续证明，这个博主有写(https://blog.csdn.net/lemon_tree12138/article/details/50605563) 关键代码： func OddEvenSort(arr []int) []int { length :=len(arr) if length &amp;lt;=1{ return arr } n:=1 isexchage := false for i:=n%2;i&amp;lt;length;i+=2 { if i+1&amp;lt;length &amp;amp;&amp;amp; arr[i]&amp;lt;arr[i+1] { arr[i],arr[i+1]=arr[i+1],arr[i] isexchage =true } } n++ for i:=n%2;i&amp;lt;length;i+=2 { if i+1&amp;lt;length &amp;amp;&amp;amp; arr[i]&amp;lt;arr[i+1] { arr[i],arr[i+1]=arr[i+1],arr[i] isexchage =true } } if isexchage { arr = OddEvenSort(arr) } return arr } </description>
    </item>
    
    <item>
      <title>Data_Struct_QuickSort</title>
      <link>https://xiet16.github.io/post/data_struct_quicksort/</link>
      <pubDate>Sun, 21 Mar 2021 18:27:13 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_quicksort/</guid>
      <description> 快速排序: 特点: 取基数，以基数为基准，将数组分为大于基数，等于基数，小于基数三个数组 递归再进行快速排序 关键代码 base:=arr[0] low:=[]int{} high:=[]int{} mid:=[]int{} mid=append(mid,base) for i:=1;i&amp;lt;length;i++ { if base&amp;gt;arr[i] { low=append(low,arr[i]) }else if base &amp;lt;arr[i] { high=append(high,arr[i]) }else { mid=append(mid,arr[i]) } } low,high = QuickSort(low),QuickSort(high) res:=append(append(high,mid...),low...) </description>
    </item>
    
    <item>
      <title>Data_Struct_HeapSort</title>
      <link>https://xiet16.github.io/post/data_struct_heapsort/</link>
      <pubDate>Sun, 21 Mar 2021 17:15:34 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_heapsort/</guid>
      <description>堆排序 原理: 堆排序就是二叉树排序 假设5&amp;gt;3, 3&amp;gt;1 , 则 5&amp;gt;1 循环次数 假设把数组看成如下树形结构 N1(a[n]) N2(a[2*n+1]) N3(a[2*n +2]) N4(a[2*n+1]) N5(a[2*n +2]) N6(a[2*n+1]) N7(a[2*n +2]) 深度: length/2 +1 第一步:N2，N4,N5 做三节点排序，把最小的值赋给N2节点 第二步:N3,N6,N7 做三节点排序，把最小值赋给N3 第三步:同理，N1,N2,N3 做三节点排序，把最小值赋给N1，这时候，数组的第1个就是最小值 第四步：数组第1位和最后一位做调换，长度减1，当做新数组，进入下一次循环（重复第一第二第三步骤） 关键代码 deap :=length/2+1 //计算深度 for i:=deap-1;i&amp;gt;=0;i-- { maxValue := i leftChildren:=2*i +1 //左孩子节点 rightChildren :=2*i+2 //右孩子节点 //防止数组溢出 if leftChildren &amp;lt;= length-1 &amp;amp;&amp;amp; arr[leftChildren]&amp;lt;arr[maxValue]{ //arr[leftChildren],arr[maxValue]=arr[maxValue],arr[leftChildren] //这样写也行 maxValue = leftChildren } if rightChildren &amp;lt;=length-1 &amp;amp;&amp;amp; arr[rightChildren]&amp;lt;arr[maxValue] { //arr[rightChildren],arr[maxValue]=arr[maxValue],arr[rightChildren] maxValue =rightChildren // } if maxValue!</description>
    </item>
    
    <item>
      <title>Data_Struct_BubbleSort</title>
      <link>https://xiet16.github.io/post/data_struct_bubblesort/</link>
      <pubDate>Sun, 21 Mar 2021 14:27:44 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_bubblesort/</guid>
      <description>冒泡排序：
特点： 循环两两交换，每一次内循环，都有会产生一个最大或者最小值， 最大最小值会沉底，其他值往上冒 效率O(N*N) 和选择排序法的区别 两者本质上都是每次循环都是依次比较，取出最大或最小值 选择排序循环次数是 (n-1)+(n-2)+...+1 冒泡排序循环次数是 n+(n-1)+(n-2)+...+1 假设有一组数据 6,2,8,7,1,0,5 第一步：第一次内循环 6和2对比，6,2,8,7,1,0,5 2和8对比，6,8,2,7,1,0,5 2和7对比，6,8,7,2,1,0,5 2和1对比，6,8,7,2,1,0,5 1和0对比，6,8,7,2,1,0,5 0和5对比，6,8,7,2,1,5,0 第二步：第二次内循环 6和8对比，8,6,7,2,1,5,0 6和7对比，8,7,6,2,1,5,0 6和2对比，8,7,6,2,1,5,0 2和1对比，8,7,6,2,1,5,0 1和5对比，8,7,6,2,5,1,0 依次类推 主要代码：	for i:=0;i&amp;lt;length-1;i++{ isexchange:=false for j:=0;j&amp;lt;length-1-i;j++ { if arr[j]&amp;lt;arr[j+1] { arr[j],arr[j+1]=arr[j+1],arr[j] isexchange =true } } if !isexchange { break } fmt.Println(arr) } </description>
    </item>
    
    <item>
      <title>Data_Struct_InsertSort</title>
      <link>https://xiet16.github.io/post/data_struct_insertsort/</link>
      <pubDate>Sun, 21 Mar 2021 12:29:54 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_insertsort/</guid>
      <description>插入排序法 原理： 第一步：取出要对比的数据 第二步：找到要插入的位置 第三步：插入位置后的数据往前或后移 第四步：插入第一步取出的数据 实现：这里是往前插入，降序 {6,2,8,7,1,0,5} 第一步：从第二个数据开始，取出2，2&amp;lt;6 ,不做操作 第二步：取出8, 8&amp;gt;2, 赋值第三位（也就是8的位置）等于2，继续对比 8&amp;gt;6, 把6赋值第二位，然后数组已经到了临界，赋值第一位为8 第三步：取出7，循环第二步的做法 关键点： 移动 赋值 区别选择排序法 选择排序法是分别循环找第一个位置，第二个位置，第三个位置，第n个位置的值 插入排序是给值找位置 关键代码: for i:=1;i&amp;lt;length;i++ { j:=i-1 backup:=arr[i] //取出要找位置的值 for j&amp;gt;=0 &amp;amp;&amp;amp;arr[j]&amp;lt;backup { arr[j+1]=arr[j] //往后移动 j-- } arr[j+1]=backup //插入 fmt.Println(arr) } </description>
    </item>
    
    <item>
      <title>Data_Struct_SelectionSort</title>
      <link>https://xiet16.github.io/post/data_struct_selectionsort/</link>
      <pubDate>Sun, 21 Mar 2021 08:00:18 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_selectionsort/</guid>
      <description>择排序法： 每一次循环，都能取出一个最大值或者最小值 最后一个值不需要，不需要对比 效率是n*(n-1）/2 假设有这个的一个数组 6,2,8,7,1,0,5 第一次循环：6 和 其他值比较， 取出最大值 8，剩下的 2,6,7,1,0,5（注意6的位置） 第二次循环：2和 其他值比较，取出最大值 7，剩下的 2,6,1,0,5 以此类推 所以循环次数是(n-1)*n 字符串比较： 可能是地址比较，不是字符串比较，go 的版本优化 “a”&amp;gt;“b” 每个字母分别比较： strings.Compare(&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;) 关键代码 for i:=0;i&amp;lt;length-1;i++ { for j:=i+1;j&amp;lt;length;j++ { if arr[i]&amp;lt;arr[j] { arr[i],arr[j]=arr[j],arr[i] } } 总的比较次数N=(n-1）+(n-2）+...+1=n*(n-1）/2 </description>
    </item>
    
    <item>
      <title>Data_Struct_Link</title>
      <link>https://xiet16.github.io/post/data_struct_storagelink/</link>
      <pubDate>Sun, 21 Mar 2021 01:16:40 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_storagelink/</guid>
      <description>链表 地址不连续 删除插入O(1) 查找修改O(n) 顺序表： 查找修改 O(1) 内存连续 删除、插入O(n) 计算机理论上不存在大片连续的内存 为什么使用链表： 方便内存扩展，以及使用计算机内存碎片 节点的定义：数据+指向下一个数据的指针 type Node struct { data interface{} pNext *Node //存储下一个节点的地址 } 假设有一组数据： a d f h e 栈的特点：先进后出 实现: 头部插入，头部取出 type Node struct { data interface{} pNext *Node //存储下一个节点的地址 } 第一步：压入a 第二步：压入d, 这时数据的内存大致可以理解 d a 第三步：压入f, 这时数据的内存大致可以理解 f d a 同理：最后是 e h f d a 取得时候 从e 往下去 队列的特点 ： 先进先出 实现：尾部插入，头部取出，也可以反着来 type LinkQueue struct { front *Node //头部节点 rear *Node //尾部节点 } 第一步：压入a ， front , rear 都指向a 第二步：压入d, 这时数据的内存大致可以理解 d a , front 指向a, rear 都指向d 第三步：压入f, 这时数据的内存大致可以理解 f d a, front 指向a, rear 都指向f 同理：最后是 e h f d a, front 指向a, rear 都指向e 取的时候，操作front, 操作上的区别，队列是两个node, 主要它用来记录首尾的节点 </description>
    </item>
    
    <item>
      <title>Data_Struct_Queue</title>
      <link>https://xiet16.github.io/post/data_struct_queue/</link>
      <pubDate>Sat, 20 Mar 2021 22:25:58 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_queue/</guid>
      <description>队列: 特点： 先进先出 广度遍历 顺序队列的取出可能会很耗内存资源，因为每次都要往前移动 环形队列最多存储size-1个数据，空一格空格表示数据已满 假设 a b c d e f h k 假设用队列递归： 第一步：压入a, 取出a 第二步：压入bc,取出bc 第三步：压入def, 取出def 第四步：压入hk, 取出hk 假设用栈： 第一步：压入a, 取出a 第二步：压入bc,取出c 第三步：压入def,取出f 第四步：压入hk,取出k 第五步：取出hedb 所以栈是深度遍历 </description>
    </item>
    
    <item>
      <title>Aliyun_minikube_install</title>
      <link>https://xiet16.github.io/post/aliyun_minikube_install/</link>
      <pubDate>Fri, 19 Mar 2021 12:17:07 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/aliyun_minikube_install/</guid>
      <description>1、安装docker 2、安装minikube 下载minikube curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-1.9.2-0.x86_64.rpm sudo rpm -ivh minikube-1.9.2-0.x86_64.rpm 添加k8s 用户 sudo useradd k8s sudo passwd k8s sudo usermod -aG docker k8s chmod u+w /etc/sudoers vim /etc/sudoers chmod u-w /etc/sudoers 切换用户 su k8s 环境还是上一个用户的 su - k8s 3、执行minikube start minikube start \ --image-mirror-country=cn \ --registry-mirror=https://xxx.mirror.aliyuncs.com \ --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers \ --iso-url=https://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/iso/minikube-v1.9.0.iso 3、启动 minikube dashboard minikube dashboard 访问minikube dashboard http://47.104.237.197:33567/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/#/node?namespace=default 相关url: https://blog.csdn.net/qq_25951401/article/details/105961820 http://www.bubuko.com/infodetail-3673213.html curl -Lo minikube https://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v1.13.0/minikube-linux-amd64 &amp;amp;&amp;amp; chmod +x minikube &amp;amp;&amp;amp; sudo mv minikube /usr/local/bin/ </description>
    </item>
    
    <item>
      <title>SequenceList_Array</title>
      <link>https://xiet16.github.io/post/sequencelist_array/</link>
      <pubDate>Thu, 18 Mar 2021 20:52:13 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/sequencelist_array/</guid>
      <description>顺序表和数组
1、数组的特点：
(1)长度固定
(2)内存连续
(3)是值类型
2、假设有两组数组
d n f l o e
c b d n q i
顺序表的插入：
开辟一块空间，然后数据往后添加
顺序表的删除：（假设要删除数组1中的f）
找到f 后的数据，往前挪，然后删除e 对应的空间块，压缩内存
顺序表的合并：
开辟一块新的内存，一个个数据往后添加
顺序表效率：
查找：1次
删除：最坏n次
插入：最坏n次</description>
    </item>
    
    <item>
      <title>Go_tag</title>
      <link>https://xiet16.github.io/post/go_tag/</link>
      <pubDate>Thu, 18 Mar 2021 17:48:27 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/go_tag/</guid>
      <description>Tag: 结构体字段声明后面跟着一个可选字符串
使用场景:
结合中间件做数据校验</description>
    </item>
    
    <item>
      <title>Go_env_init</title>
      <link>https://xiet16.github.io/post/go_env_init/</link>
      <pubDate>Thu, 18 Mar 2021 15:33:27 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/go_env_init/</guid>
      <description>1、登陆https://studygolang.com/dl下载安装包(这里忽略安装过程)
2、环境配置(开启Module和代理，不然可能更新不下来依赖包)
go env -w GO111MODULE=on
go env -w GOPROXY=https://goproxy.io,direct
3、新建项目
(1)首先用vscode 打开一个空文件夹,添加main.go 文件 并编辑好代码
(2)在终端中执行以下命令
go mod init &amp;ldquo;your_project_name&amp;rdquo;
go mod tidy
go mod vendor
go modules 我的理解是go 项目依赖包管理。执行 go mod init &amp;ldquo;xxx&amp;rdquo; 以后 会生成一个go.mod的文件，这个文件展示的是项目所依赖的依赖包以及版本信息 所以如果要改某个包的版本，可以手动改，然后执行go mod tidy. go mod tidy 是更新依赖包命令，这里包含删除、新增、修改依赖包。go mod vendor 是讲依 赖包下载到vendor 文件夹。顺便提一下，go modules 是1.11后新加的特性之前 是GOPATH的方式</description>
    </item>
    
    <item>
      <title>ElasticSearch</title>
      <link>https://xiet16.github.io/post/elasticsearch/</link>
      <pubDate>Thu, 18 Mar 2021 09:29:52 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/elasticsearch/</guid>
      <description>1、ElasticSearch 规范:
2、ElasticSearch 踩过的坑:
(1)es中展示的是北京时间,存的时间是utc时间
&amp;ldquo;script&amp;rdquo;: { &amp;ldquo;source&amp;rdquo;: &amp;quot; return (new Date().getTime() - doc[&amp;lsquo;ArrivalDate&amp;rsquo;].value.toInstant().toEpochMilli() + 28800000) &amp;quot; }
(2)es中distinc 是不准的
&amp;ldquo;cardinality&amp;rdquo;: {&amp;ldquo;precision_threshold&amp;rdquo;: 100000,&amp;ldquo;field&amp;rdquo;: &amp;ldquo;Single_NO&amp;rdquo;}</description>
    </item>
    
    <item>
      <title>Design_Patterns</title>
      <link>https://xiet16.github.io/post/design_patterns/</link>
      <pubDate>Thu, 18 Mar 2021 08:51:04 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/design_patterns/</guid>
      <description>设计模式七大原则
代码网址:
https://github.com/xiet16/go_design_patterns
开闭原则: 对扩展开放，对修改关闭
理解: 当新增某一功能时，应该与原有的代码逻辑没有关系，也就是不需要修改原有的代码
里式替换原则:父类出现的任何地方，都可以用子类替换
理解:面向对象继承的体现，子类继承父类，子类就拥有父类的一切行为和属性
单一职责原则:一个类有且仅有一个引起它变化的原因，否则这个类就需要拆分
依赖倒置原则:抽象不依赖于具象，具象依赖抽象
理解:抽象类或者父类不关心继承类的实现，但是继承类要实现抽象类的约定
接口隔离原则:客户端不应该去依赖一个它不使用的接口(一个类对另一个类的依赖，应该在最小的接口上)
理解:某一功能接口的定义或者暴露，应该是尽可能少和紧密相关的
(迪米特原则)最少知道原则:高内聚
理解:后面这两个原则，暂时不做解释，虽有点的理解
合成复用原则:
理解:这个原则是说用组合的方式而不是继承的方式复用，但是我觉得要是具体场景，原则性不是很强</description>
    </item>
    
    <item>
      <title>Hugo_Web_Create</title>
      <link>https://xiet16.github.io/post/hugocreate/</link>
      <pubDate>Wed, 17 Mar 2021 19:29:21 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/hugocreate/</guid>
      <description>1、装好git 和hugo
2、新建博客站点
hugo new site myblog
3、进入myblog/themes 文件夹，下载主题并命名文件夹
git clone https://github.com/vaga/hugo-theme-m10c.git m10c
4、在myblog 文件夹下执行
hugo server -t m10c &amp;ndash;buildDrafts
5、在myblog 文件夹下创建md 文件
hugo new post/hugocreate.md
6、生成静态网页(https://github_name.github.io)要用自己名字，不然访问不了
hugo &amp;ndash;theme=m10c &amp;ndash;baseUrl=&amp;ldquo;https://xiet16.github.io&amp;rdquo; &amp;ndash;buildDrafts
7、编译好的网页放在./public 目录下面，所有要把public文件的内容传到https://github_name.github.io.git仓库上
8、再建一个仓库存myblog 项目就好了
9、上传可以建一个shell脚本
10、git 保存密码命令
git config &amp;ndash;global credential.helper store</description>
    </item>
    
  </channel>
</rss>
