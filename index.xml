<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>xietie blog</title>
    <link>https://xiet16.github.io/</link>
    <description>Recent content on xietie blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 24 Mar 2021 11:30:14 +0800</lastBuildDate><atom:link href="https://xiet16.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Data_Struct_MiddleSearch</title>
      <link>https://xiet16.github.io/post/data_struct_middlesearch/</link>
      <pubDate>Wed, 24 Mar 2021 11:30:14 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_middlesearch/</guid>
      <description>中值查找: 二分查找的优化，本质是值比例查找 /* 中值搜索: 根据值比例求中值 1,2,3,4,5,6,7,8,9,10 共10位数，取 8 在哪个位置 left:0 right:9 data/就得出值 (arr[right]-arr[left])/(right-left) 没份的间隔是多少 求data 大概在第几份 (data-arr[left])*(right-left)/(arr[right]-arr[left]) = n 中间值下标就是 left+ n */ func MiddleSearch(arr []int,data int) []int { length:=len(arr) if length &amp;lt;1 { return nil } left:=0 right:=length-1 res:=[]int{} if left&amp;lt;right { //mid:=(right+left)/2 //优化欠 allv := float64(arr[right]-arr[left]) leftv := float64(data-arr[left]) diff := float64(right-left) mid:= int(float64(left)+ leftv/allv*diff) if mid&amp;lt;0 || mid &amp;gt;length { return nil } if arr[mid] &amp;gt;data { right =mid-1 }else if arr[mid]&amp;lt;data { left = mid+1 }else { res =append(res,mid) for i:=mid+1;i&amp;lt;=right;i++ { if arr[i]==data { res=append(res,i) }else { break } } for i:=mid-1;i&amp;gt;=left;i-- { if arr[i]==data { res=append(res,i) }else { break } } } } return res } </description>
    </item>
    
    <item>
      <title>Data_Struct_BinarySearch</title>
      <link>https://xiet16.github.io/post/data_struct_binarysearch/</link>
      <pubDate>Wed, 24 Mar 2021 11:23:01 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_binarysearch/</guid>
      <description>二分查找： 从中间查找，前提是排了序的数据 关键代码： func BinarySearch(arr[] int ,data int) int { left:=0 right:=len(arr)-1 for left &amp;lt;right{ mid := (left+right)/2 if arr[mid]&amp;gt;data { left =mid+1 }else if arr[mid]&amp;lt;data{ right=mid-1 }else { return mid } } return -1 } </description>
    </item>
    
    <item>
      <title>Data_Struct_QuickSortPlus</title>
      <link>https://xiet16.github.io/post/data_struct_quicksortplus/</link>
      <pubDate>Wed, 24 Mar 2021 10:16:01 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_quicksortplus/</guid>
      <description>快速排序升级算法： 前面的快速排序有个弊端，就是频繁的开辟数组，造成内存不断的飙升，而且数据超过2000w时，排序的时间大大增加 原理: 取基数，小于基数的往左边插入，大于基数的往右边插入，等于的记录等于的起始位置 所以会有几个下标，[0-lt] 是小于 基数的下标，[lt-i]是等于基数的下标，[i-gt]是移动下标，当i==gt 时，此时[gt-length]是大于基数的下标 /* 3,2,8,6,9 1,5 取基数，这里每次都取arr[0] 小于的从第0位开始交换 大于的从最后一位开始放尽管扔到一变就好了 3,2,8,6,9,1,5 第一次循环，vdata=arr[0]=3 ,不动 3,2,5,6,9,1,8 第二次循环 3&amp;lt;a[2]=8 gt-1 3,2,1,6,9,5,8 第三次循环 3&amp;lt;a[2]=5 gt -1 3,2,1,6,9,5,8 第四次循环 3&amp;gt;a[2]=1 这时候是不变的 3,2,1,9,6,5,8 第六次循环 3《a[3]=6 这时候是不变的 gt-1 3,2,1,9,6,5,8 第七次循环 3《a[3]=9 这时候是不变的 gt-1 ， 这个时候i==gt 1,2,3,9,6,5,8 第八次循环 */ 关键代码: func QuickInsertSort(arr []int,left int,right int) []int { //数组只剩3个时，用插入排序 if right-left &amp;lt;3 { InsertQuick(arr,left,right) }else { //随机找一个数字 Swap(arr,left,rand.Int()%(right-left+1)+left) vdata :=arr[left] //基数 lt :=left //arr[left+1,lt] &amp;lt;vdata gt:=right+1 //arr[gt.</description>
    </item>
    
    <item>
      <title>Data_Struct_CockSort</title>
      <link>https://xiet16.github.io/post/data_struct_cocksort/</link>
      <pubDate>Tue, 23 Mar 2021 07:14:40 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_cocksort/</guid>
      <description>鸡尾酒排序: 本质就是循环双边冒泡，每次冒泡都会有一个值沉底或值飘起 假设有一组数据: [350 180 166 100 97 87 35 32 16 15 6 5 4 4 3 2] 下边关键代码部分运行过程: 0 [4 6 32 5 166 4 350 180 3 2 87 15 97 35 16 100] 1 [6 32 5 166 4 350 180 100 4 3 2 87 15 97 35 16] 2 [32 6 166 5 350 180 100 97 4 4 3 2 87 15 35 16] 3 [32 166 6 350 180 100 97 87 5 4 4 3 2 35 15 16] 4 [166 32 350 180 100 97 87 35 6 5 4 4 3 2 16 15] 5 [166 350 180 100 97 87 35 32 16 6 5 4 4 3 2 15] 6 [350 180 166 100 97 87 35 32 16 15 6 5 4 4 3 2] 7 [350 180 166 100 97 87 35 32 16 15 6 5 4 4 3 2] 关键代码: for i:=0;i&amp;lt;length;i++ { left :=0; right :=length-1 for left&amp;lt;=right { if arr[left]&amp;lt;arr[left+1] { arr[left],arr[left+1]=arr[left+1],arr[left] } left++ if arr[right]&amp;gt;arr[right-1] { arr[right],arr[right-1]=arr[right-1],arr[right] } right-- } fmt.</description>
    </item>
    
    <item>
      <title>Go_channel</title>
      <link>https://xiet16.github.io/post/go_channel/</link>
      <pubDate>Mon, 22 Mar 2021 19:42:00 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/go_channel/</guid>
      <description>感慨一下：一直想总结一下这个来着，但总有些心虚，说到底，一是没有仔仔细细证明过底层的代码。二是，感觉channel 这东西，说简单，也 简单，说不简单吧。总想着，自己是不是还有没遇到的坑。不过还是先总结一下吧 channel： 特点： 1、同一时间点，只能被一个协程访问,也就是说它是同步的 、线程安全的， 2、管道分为有缓冲和无缓冲 3、无缓冲情况下：在接收者准备好之前，发送者是阻塞的也就是说，首先得有接收者开始接收，才会开始发送 4、有缓冲情况下：在buf 满之后，直到有接收者接收，发送者才可以发送 type hchan struct { qcount uint // total data in the queue dataqsiz uint // size of the circular queue buf unsafe.Pointer // points to an array of dataqsiz elements elemsize uint16 closed uint32 elemtype *_type // element type sendx uint // send index recvx uint // receive index recvq waitq // list of recv waiters sendq waitq // list of send waiters // lock protects all fields in hchan, as well as several // fields in sudogs blocked on this channel.</description>
    </item>
    
    <item>
      <title>Data_Struct_CountSort</title>
      <link>https://xiet16.github.io/post/data_struct_countsort/</link>
      <pubDate>Mon, 22 Mar 2021 12:05:28 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_countsort/</guid>
      <description>统计计数算法： 不基于元素比较的排序算法 举个简单的例子讲吧： 假设有一组数据： 4，3，6, 9，7 ，8 (1)取其中最大值9，这里通过一轮比较就可以得出 (2)建一个长度为9+1=10的数组countarr，用数组的下标代表数据， 也就是arr[9] 中的[9]代表9 ,arr[9] 代表出现多少次 (3) 统计次数后的countarr: [0 0 0 1 1 0 1 1 1 1] (4) 其实这个时候已经排好序了，只要用下标和个数循环输出就行 (5) 有时候我们想知道，数组中的任意某个值是第几位，这时候进一步衍生下面的步骤 循环往后叠加，countarr[i]+=countarr[i-1],这里需要理解，比如[0 0 0 1 1 变为 [0 0 0 1 2 这里的1变为2，代表的是[4] 排在第二位，以此类推完整的是这样 [0 0 0 1 2 2 3 4 5 6] 最后一位6很容易看出来，一共有6个数据，下标[9] 在第六位 关键代码： maxValue := GetMaxValue(arr) countArr:=make([]int,maxValue+1) res:=make([]int,length) for i:=0;i&amp;lt;length;i++ { countArr[arr[i]]++ //统计次数 } fmt.Println(&amp;quot;统计次数:&amp;quot;,countArr) for i:=1;i&amp;lt;=maxValue;i++ { countArr[i]+=countArr[i-1] //叠加 } fmt.</description>
    </item>
    
    <item>
      <title>Data_Struct_RadixSort</title>
      <link>https://xiet16.github.io/post/data_struct_radixsort/</link>
      <pubDate>Mon, 22 Mar 2021 12:04:47 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_radixsort/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Data_Struct_ShellSort</title>
      <link>https://xiet16.github.io/post/data_struct_shellsort/</link>
      <pubDate>Mon, 22 Mar 2021 08:45:08 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_shellsort/</guid>
      <description> 希尔排序： 特点: 是一种步长收缩算法，一般初次增量为序列的一半 本质上是一种分组 时间复杂度为O(n3/2) 可以用多线程 关键点： 如何定义步长 关键代码 gap :=length/2 for gap&amp;gt;0 { for i:=0;i&amp;lt;gap;i++ { ShellStep(arr,i,gap) } gap/=2 } //间隔为步长的插入算法 length:=len(arr) for i:=start+gap;i&amp;lt;length;i+=gap { //间隔为gap 的插入排序 backup :=arr[i] j:=i-gap //数据循环往后移动 for j&amp;gt;=0 &amp;amp;&amp;amp; backup&amp;gt;arr[j]{ arr[j+gap] = arr[j] j-=gap } arr[j+gap]=backup //插入 fmt.Println(arr) } </description>
    </item>
    
    <item>
      <title>Data_Struct_MergeSort</title>
      <link>https://xiet16.github.io/post/data_struct_mergesort/</link>
      <pubDate>Sun, 21 Mar 2021 22:13:32 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_mergesort/</guid>
      <description>归并排序： 将数据切割成多段进行排序 然后再多段合并 好处: 内存不够时，可以节约内存 func MergeSort(arr []int) []int { length:=len(arr) if length&amp;lt;=1 { return arr } n:=length/2 frontArr :=MergeSort(arr[:n]) rearArr :=MergeSort(arr[n:]) return merge(frontArr,rearArr) } func merge(leftArr,rightArr []int)[]int { leftIndex:=0 rightIndex :=0 res:=[]int{} for leftIndex&amp;lt;len(leftArr)&amp;amp;&amp;amp;rightIndex&amp;lt;len(rightArr){ if leftArr[leftIndex] &amp;gt;rightArr[rightIndex] { res=append(res,leftArr[leftIndex]) leftIndex ++ }else if leftArr[leftIndex] &amp;lt; rightArr[rightIndex] { res = append(res,rightArr[rightIndex]) rightIndex++ }else { res =append(res,leftArr[leftIndex],rightArr[rightIndex]) leftIndex++ rightIndex++ } } for len(leftArr)&amp;gt;leftIndex { res =append(res,leftArr[leftIndex]) leftIndex++ } for len(rightArr)&amp;gt;rightIndex { res =append(res,rightArr[rightIndex]) rightIndex++ } return res } </description>
    </item>
    
    <item>
      <title>Data_Struct_OddEvenSort</title>
      <link>https://xiet16.github.io/post/data_struct_oddevensort/</link>
      <pubDate>Sun, 21 Mar 2021 19:09:35 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_oddevensort/</guid>
      <description>奇偶排序： 以奇数和偶数为基准，对整个数组进行排序，排序的元素只有两个元素（基数和右侧相邻元素） 如何证明奇偶排序的可行性？后续证明，这个博主有写(https://blog.csdn.net/lemon_tree12138/article/details/50605563) 关键代码： func OddEvenSort(arr []int) []int { length :=len(arr) if length &amp;lt;=1{ return arr } n:=1 isexchage := false for i:=n%2;i&amp;lt;length;i+=2 { if i+1&amp;lt;length &amp;amp;&amp;amp; arr[i]&amp;lt;arr[i+1] { arr[i],arr[i+1]=arr[i+1],arr[i] isexchage =true } } n++ for i:=n%2;i&amp;lt;length;i+=2 { if i+1&amp;lt;length &amp;amp;&amp;amp; arr[i]&amp;lt;arr[i+1] { arr[i],arr[i+1]=arr[i+1],arr[i] isexchage =true } } if isexchage { arr = OddEvenSort(arr) } return arr } </description>
    </item>
    
    <item>
      <title>Data_Struct_QuickSort</title>
      <link>https://xiet16.github.io/post/data_struct_quicksort/</link>
      <pubDate>Sun, 21 Mar 2021 18:27:13 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_quicksort/</guid>
      <description> 快速排序: 特点: 取基数，以基数为基准，将数组分为大于基数，等于基数，小于基数三个数组 递归再进行快速排序 关键代码 base:=arr[0] low:=[]int{} high:=[]int{} mid:=[]int{} mid=append(mid,base) for i:=1;i&amp;lt;length;i++ { if base&amp;gt;arr[i] { low=append(low,arr[i]) }else if base &amp;lt;arr[i] { high=append(high,arr[i]) }else { mid=append(mid,arr[i]) } } low,high = QuickSort(low),QuickSort(high) res:=append(append(high,mid...),low...) </description>
    </item>
    
    <item>
      <title>Data_Struct_HeapSort</title>
      <link>https://xiet16.github.io/post/data_struct_heapsort/</link>
      <pubDate>Sun, 21 Mar 2021 17:15:34 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_heapsort/</guid>
      <description>堆排序 原理: 堆排序就是二叉树排序 假设5&amp;gt;3, 3&amp;gt;1 , 则 5&amp;gt;1 循环次数 假设把数组看成如下树形结构 N1(a[n]) N2(a[2*n+1]) N3(a[2*n +2]) N4(a[2*n+1]) N5(a[2*n +2]) N6(a[2*n+1]) N7(a[2*n +2]) 深度: length/2 +1 第一步:N2，N4,N5 做三节点排序，把最小的值赋给N2节点 第二步:N3,N6,N7 做三节点排序，把最小值赋给N3 第三步:同理，N1,N2,N3 做三节点排序，把最小值赋给N1，这时候，数组的第1个就是最小值 第四步：数组第1位和最后一位做调换，长度减1，当做新数组，进入下一次循环（重复第一第二第三步骤） 关键代码 deap :=length/2+1 //计算深度 for i:=deap-1;i&amp;gt;=0;i-- { maxValue := i leftChildren:=2*i +1 //左孩子节点 rightChildren :=2*i+2 //右孩子节点 //防止数组溢出 if leftChildren &amp;lt;= length-1 &amp;amp;&amp;amp; arr[leftChildren]&amp;lt;arr[maxValue]{ //arr[leftChildren],arr[maxValue]=arr[maxValue],arr[leftChildren] //这样写也行 maxValue = leftChildren } if rightChildren &amp;lt;=length-1 &amp;amp;&amp;amp; arr[rightChildren]&amp;lt;arr[maxValue] { //arr[rightChildren],arr[maxValue]=arr[maxValue],arr[rightChildren] maxValue =rightChildren // } if maxValue!</description>
    </item>
    
    <item>
      <title>Data_Struct_BubbleSort</title>
      <link>https://xiet16.github.io/post/data_struct_bubblesort/</link>
      <pubDate>Sun, 21 Mar 2021 14:27:44 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_bubblesort/</guid>
      <description>冒泡排序：
特点： 循环两两交换，每一次内循环，都有会产生一个最大或者最小值， 最大最小值会沉底，其他值往上冒 效率O(N*N) 和选择排序法的区别 两者本质上都是每次循环都是依次比较，取出最大或最小值 选择排序循环次数是 (n-1)+(n-2)+...+1 冒泡排序循环次数是 n+(n-1)+(n-2)+...+1 假设有一组数据 6,2,8,7,1,0,5 第一步：第一次内循环 6和2对比，6,2,8,7,1,0,5 2和8对比，6,8,2,7,1,0,5 2和7对比，6,8,7,2,1,0,5 2和1对比，6,8,7,2,1,0,5 1和0对比，6,8,7,2,1,0,5 0和5对比，6,8,7,2,1,5,0 第二步：第二次内循环 6和8对比，8,6,7,2,1,5,0 6和7对比，8,7,6,2,1,5,0 6和2对比，8,7,6,2,1,5,0 2和1对比，8,7,6,2,1,5,0 1和5对比，8,7,6,2,5,1,0 依次类推 主要代码：	for i:=0;i&amp;lt;length-1;i++{ isexchange:=false for j:=0;j&amp;lt;length-1-i;j++ { if arr[j]&amp;lt;arr[j+1] { arr[j],arr[j+1]=arr[j+1],arr[j] isexchange =true } } if !isexchange { break } fmt.Println(arr) } </description>
    </item>
    
    <item>
      <title>Data_Struct_InsertSort</title>
      <link>https://xiet16.github.io/post/data_struct_insertsort/</link>
      <pubDate>Sun, 21 Mar 2021 12:29:54 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_insertsort/</guid>
      <description>插入排序法 原理： 第一步：取出要对比的数据 第二步：找到要插入的位置 第三步：插入位置后的数据往前或后移 第四步：插入第一步取出的数据 实现：这里是往前插入，降序 {6,2,8,7,1,0,5} 第一步：从第二个数据开始，取出2，2&amp;lt;6 ,不做操作 第二步：取出8, 8&amp;gt;2, 赋值第三位（也就是8的位置）等于2，继续对比 8&amp;gt;6, 把6赋值第二位，然后数组已经到了临界，赋值第一位为8 第三步：取出7，循环第二步的做法 关键点： 移动 赋值 区别选择排序法 选择排序法是分别循环找第一个位置，第二个位置，第三个位置，第n个位置的值 插入排序是给值找位置 关键代码: for i:=1;i&amp;lt;length;i++ { j:=i-1 backup:=arr[i] //取出要找位置的值 for j&amp;gt;=0 &amp;amp;&amp;amp;arr[j]&amp;lt;backup { arr[j+1]=arr[j] //往后移动 j-- } arr[j+1]=backup //插入 fmt.Println(arr) } </description>
    </item>
    
    <item>
      <title>Data_Struct_SelectionSort</title>
      <link>https://xiet16.github.io/post/data_struct_selectionsort/</link>
      <pubDate>Sun, 21 Mar 2021 08:00:18 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_selectionsort/</guid>
      <description>择排序法： 每一次循环，都能取出一个最大值或者最小值 最后一个值不需要，不需要对比 效率是n*(n-1）/2 假设有这个的一个数组 6,2,8,7,1,0,5 第一次循环：6 和 其他值比较， 取出最大值 8，剩下的 2,6,7,1,0,5（注意6的位置） 第二次循环：2和 其他值比较，取出最大值 7，剩下的 2,6,1,0,5 以此类推 所以循环次数是(n-1)*n 字符串比较： 可能是地址比较，不是字符串比较，go 的版本优化 “a”&amp;gt;“b” 每个字母分别比较： strings.Compare(&amp;quot;a&amp;quot;,&amp;quot;a&amp;quot;) 关键代码 for i:=0;i&amp;lt;length-1;i++ { for j:=i+1;j&amp;lt;length;j++ { if arr[i]&amp;lt;arr[j] { arr[i],arr[j]=arr[j],arr[i] } } 总的比较次数N=(n-1）+(n-2）+...+1=n*(n-1）/2 </description>
    </item>
    
    <item>
      <title>Data_Struct_Link</title>
      <link>https://xiet16.github.io/post/data_struct_link/</link>
      <pubDate>Sun, 21 Mar 2021 01:16:40 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_link/</guid>
      <description>链表 地址不连续 删除插入O(1) 查找修改O(n) 顺序表： 查找修改 O(1) 内存连续 删除、插入O(n) 计算机理论上不存在大片连续的内存 为什么使用链表： 方便内存扩展，以及使用计算机内存碎片 节点的定义：数据+指向下一个数据的指针 type Node struct { data interface{} pNext *Node //存储下一个节点的地址 } 假设有一组数据： a d f h e 栈的特点：先进后出 实现: 头部插入，头部取出 type Node struct { data interface{} pNext *Node //存储下一个节点的地址 } 第一步：压入a 第二步：压入d, 这时数据的内存大致可以理解 d a 第三步：压入f, 这时数据的内存大致可以理解 f d a 同理：最后是 e h f d a 取得时候 从e 往下去 队列的特点 ： 先进先出 实现：尾部插入，头部取出，也可以反着来 type LinkQueue struct { front *Node //头部节点 rear *Node //尾部节点 } 第一步：压入a ， front , rear 都指向a 第二步：压入d, 这时数据的内存大致可以理解 d a , front 指向a, rear 都指向d 第三步：压入f, 这时数据的内存大致可以理解 f d a, front 指向a, rear 都指向f 同理：最后是 e h f d a, front 指向a, rear 都指向e 取的时候，操作front, 操作上的区别，队列是两个node, 主要它用来记录首尾的节点 </description>
    </item>
    
    <item>
      <title>Data_Struct_Queue</title>
      <link>https://xiet16.github.io/post/data_struct_queue/</link>
      <pubDate>Sat, 20 Mar 2021 22:25:58 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/data_struct_queue/</guid>
      <description>队列: 特点： 先进先出 广度遍历 顺序队列的取出可能会很耗内存资源，因为每次都要往前移动 环形队列最多存储size-1个数据，空一格空格表示数据已满 假设 a b c d e f h k 假设用队列递归： 第一步：压入a, 取出a 第二步：压入bc,取出bc 第三步：压入def, 取出def 第四步：压入hk, 取出hk 假设用栈： 第一步：压入a, 取出a 第二步：压入bc,取出c 第三步：压入def,取出f 第四步：压入hk,取出k 第五步：取出hedb 所以栈是深度遍历 </description>
    </item>
    
    <item>
      <title>Aliyun_minikube_install</title>
      <link>https://xiet16.github.io/post/aliyun_minikube_install/</link>
      <pubDate>Fri, 19 Mar 2021 12:17:07 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/aliyun_minikube_install/</guid>
      <description>1、安装docker 2、安装minikube 下载minikube curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-1.9.2-0.x86_64.rpm sudo rpm -ivh minikube-1.9.2-0.x86_64.rpm 添加k8s 用户 sudo useradd k8s sudo passwd k8s sudo usermod -aG docker k8s chmod u+w /etc/sudoers vim /etc/sudoers chmod u-w /etc/sudoers 切换用户 su k8s 环境还是上一个用户的 su - k8s 3、执行minikube start minikube start \ --image-mirror-country=cn \ --registry-mirror=https://xxx.mirror.aliyuncs.com \ --image-repository=registry.cn-hangzhou.aliyuncs.com/google_containers \ --iso-url=https://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/iso/minikube-v1.9.0.iso 3、启动 minikube dashboard minikube dashboard 访问minikube dashboard http://47.104.237.197:33567/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/#/node?namespace=default 相关url: https://blog.csdn.net/qq_25951401/article/details/105961820 http://www.bubuko.com/infodetail-3673213.html curl -Lo minikube https://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v1.13.0/minikube-linux-amd64 &amp;amp;&amp;amp; chmod +x minikube &amp;amp;&amp;amp; sudo mv minikube /usr/local/bin/ </description>
    </item>
    
    <item>
      <title>SequenceList_Array</title>
      <link>https://xiet16.github.io/post/sequencelist_array/</link>
      <pubDate>Thu, 18 Mar 2021 20:52:13 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/sequencelist_array/</guid>
      <description>顺序表和数组
1、数组的特点：
(1)长度固定
(2)内存连续
(3)是值类型
2、假设有两组数组
d n f l o e
c b d n q i
顺序表的插入：
开辟一块空间，然后数据往后添加
顺序表的删除：（假设要删除数组1中的f）
找到f 后的数据，往前挪，然后删除e 对应的空间块，压缩内存
顺序表的合并：
开辟一块新的内存，一个个数据往后添加
顺序表效率：
查找：1次
删除：最坏n次
插入：最坏n次</description>
    </item>
    
    <item>
      <title>Go_tag</title>
      <link>https://xiet16.github.io/post/go_tag/</link>
      <pubDate>Thu, 18 Mar 2021 17:48:27 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/go_tag/</guid>
      <description>Tag: 结构体字段声明后面跟着一个可选字符串
使用场景:
结合中间件做数据校验</description>
    </item>
    
    <item>
      <title>Go_env_init</title>
      <link>https://xiet16.github.io/post/go_env_init/</link>
      <pubDate>Thu, 18 Mar 2021 15:33:27 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/go_env_init/</guid>
      <description>1、登陆https://studygolang.com/dl下载安装包(这里忽略安装过程)
2、环境配置(开启Module和代理，不然可能更新不下来依赖包)
go env -w GO111MODULE=on
go env -w GOPROXY=https://goproxy.io,direct
3、新建项目
(1)首先用vscode 打开一个空文件夹,添加main.go 文件 并编辑好代码
(2)在终端中执行以下命令
go mod init &amp;ldquo;your_project_name&amp;rdquo;
go mod tidy
go mod vendor
go modules 我的理解是go 项目依赖包管理。执行 go mod init &amp;ldquo;xxx&amp;rdquo; 以后 会生成一个go.mod的文件，这个文件展示的是项目所依赖的依赖包以及版本信息 所以如果要改某个包的版本，可以手动改，然后执行go mod tidy. go mod tidy 是更新依赖包命令，这里包含删除、新增、修改依赖包。go mod vendor 是讲依 赖包下载到vendor 文件夹。顺便提一下，go modules 是1.11后新加的特性之前 是GOPATH的方式</description>
    </item>
    
    <item>
      <title>ElasticSearch</title>
      <link>https://xiet16.github.io/post/elasticsearch/</link>
      <pubDate>Thu, 18 Mar 2021 09:29:52 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/elasticsearch/</guid>
      <description>1、ElasticSearch 规范:
2、ElasticSearch 踩过的坑:
(1)es中展示的是北京时间,存的时间是utc时间
&amp;ldquo;script&amp;rdquo;: { &amp;ldquo;source&amp;rdquo;: &amp;quot; return (new Date().getTime() - doc[&amp;lsquo;ArrivalDate&amp;rsquo;].value.toInstant().toEpochMilli() + 28800000) &amp;quot; }
(2)es中distinc 是不准的
&amp;ldquo;cardinality&amp;rdquo;: {&amp;ldquo;precision_threshold&amp;rdquo;: 100000,&amp;ldquo;field&amp;rdquo;: &amp;ldquo;Single_NO&amp;rdquo;}</description>
    </item>
    
    <item>
      <title>ElasticSearch</title>
      <link>https://xiet16.github.io/elasticsearch/</link>
      <pubDate>Thu, 18 Mar 2021 09:26:38 +0800</pubDate>
      
      <guid>https://xiet16.github.io/elasticsearch/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Design_Patterns</title>
      <link>https://xiet16.github.io/post/design_patterns/</link>
      <pubDate>Thu, 18 Mar 2021 08:51:04 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/design_patterns/</guid>
      <description>设计模式七大原则
代码网址:
https://github.com/xiet16/go_design_patterns
开闭原则: 对扩展开放，对修改关闭
理解: 当新增某一功能时，应该与原有的代码逻辑没有关系，也就是不需要修改原有的代码
里式替换原则:父类出现的任何地方，都可以用子类替换
理解:面向对象继承的体现，子类继承父类，子类就拥有父类的一切行为和属性
单一职责原则:一个类有且仅有一个引起它变化的原因，否则这个类就需要拆分
依赖倒置原则:抽象不依赖于具象，具象依赖抽象
理解:抽象类或者父类不关心继承类的实现，但是继承类要实现抽象类的约定
接口隔离原则:客户端不应该去依赖一个它不使用的接口(一个类对另一个类的依赖，应该在最小的接口上)
理解:某一功能接口的定义或者暴露，应该是尽可能少和紧密相关的
(迪米特原则)最少知道原则:高内聚
理解:后面这两个原则，暂时不做解释，虽有点的理解
合成复用原则:
理解:这个原则是说用组合的方式而不是继承的方式复用，但是我觉得要是具体场景，原则性不是很强</description>
    </item>
    
    <item>
      <title>Hugo_Web_Create</title>
      <link>https://xiet16.github.io/post/hugocreate/</link>
      <pubDate>Wed, 17 Mar 2021 19:29:21 +0800</pubDate>
      
      <guid>https://xiet16.github.io/post/hugocreate/</guid>
      <description>1、装好git 和hugo
2、新建博客站点
hugo new site myblog
3、进入myblog/themes 文件夹，下载主题并命名文件夹
git clone https://github.com/vaga/hugo-theme-m10c.git m10c
4、在myblog 文件夹下执行
hugo server -t m10c &amp;ndash;buildDrafts
5、在myblog 文件夹下创建md 文件
hugo new post/hugocreate.md
6、生成静态网页(https://github_name.github.io)要用自己名字，不然访问不了
hugo &amp;ndash;theme=m10c &amp;ndash;baseUrl=&amp;ldquo;https://xiet16.github.io&amp;rdquo; &amp;ndash;buildDrafts
7、编译好的网页放在./public 目录下面，所有要把public文件的内容传到https://github_name.github.io.git仓库上
8、再建一个仓库存myblog 项目就好了
9、上传可以建一个shell脚本
10、git 保存密码命令
git config &amp;ndash;global credential.helper store</description>
    </item>
    
  </channel>
</rss>
